{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p>Spring Framework is a powerful framework for building enterprise-grade Java applications, supporting dependency injection, aspect-oriented programming, and more.</p> Key Features <ul> <li>Lightweight: Minimal overhead, easy integration.</li> <li>Modular: Flexible architecture for selective component use.</li> <li>Open Source: Free under the Apache License 2.0.</li> <li>Enterprise Ready: Robust features for large-scale applications.</li> <li>Testable: Built-in support for testing.</li> <li>IoC Container: Manages object creation and configuration.</li> <li>AOP: Modularizes cross-cutting concerns.</li> <li>Microservices Ready: Supports microservices with Spring Boot.</li> </ul> Spring Framework Principles <ul> <li>Choice at Every Level: Offers flexibility in architectural decisions.</li> <li>Support for Diversity: Accommodates various application architectures.</li> <li>Strong Backward Compatibility: Ensures smooth upgrades across versions.</li> <li>Careful API Design: Provides intuitive and consistent APIs.</li> <li>High Code Quality: Maintains a clean structure with no circular dependencies.</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li> <p>Install Prerequisites:</p> <ul> <li>Java Development Kit (JDK)</li> <li>Maven or Gradle</li> </ul> </li> <li> <p>Set Up a Project:</p> <ul> <li>Use Spring Initializr to bootstrap a project.</li> </ul> </li> <li> <p>Learn and Explore:</p> <ul> <li>Refer to official documentation and guides.</li> </ul> </li> </ol>"},{"location":"#core-concepts","title":"Core Concepts","text":""},{"location":"#ioc-inversion-of-control","title":"IoC (Inversion of Control)","text":"<ul> <li>Principle: Transfers control of object creation and dependency management to a framework.</li> <li>Purpose: Decouples tasks from implementation, improving modularity and testability.</li> <li>Example: Spring manages object creation and lifecycle.</li> </ul>"},{"location":"#ioc-container","title":"IoC Container","text":"<ul> <li>Definition: A framework component implementing IoC, managing object (bean) lifecycles and dependencies.</li> <li>Responsibilities:<ul> <li>Instantiate and configure beans.</li> <li>Manage bean lifecycles.</li> </ul> </li> <li>Examples: <ul> <li><code>BeanFactory</code>: Basic IoC container providing simple functionality.</li> <li><code>ApplicationContext</code>: Advanced container with additional features like AOP, event propagation and internationalization.</li> </ul> </li> </ul>"},{"location":"#di-dependency-injection","title":"DI (Dependency Injection)","text":"<ul> <li>Definition: A design pattern to achieve IoC by injecting dependencies into objects.</li> <li>Types:<ol> <li>Constructor Injection: Dependencies via constructor.</li> <li>Setter Injection: Dependencies via setter methods.</li> <li>Field Injection: Direct injection using <code>@Autowired</code> (less recommended).</li> </ol> </li> <li>Purpose: Reduces tight coupling, improving testability and maintainability.</li> </ul>"},{"location":"#relationship-between-ioc-ioc-container-and-di","title":"Relationship Between IoC, IoC Container, and DI","text":"<ul> <li>IoC is the overarching principle.</li> <li>The IoC Container is the implementation of IoC in Spring.</li> <li>DI is the design pattern used by the IoC Container to achieve IoC.</li> </ul>"},{"location":"#resources","title":"Resources","text":"<ul> <li>Official Spring Documentation</li> <li>Spring Guides</li> </ul>"},{"location":"spring-basics/","title":"Spring Framework Basics","text":""},{"location":"spring-basics/#spring-bean-lifecycle","title":"Spring Bean Lifecycle","text":"<p>The lifecycle of a Spring bean is managed by the Spring container. The main stages are:</p> Spring Bean Lifecycle <ol> <li>Instantiation: The container creates an instance of the bean.</li> <li>Populate Properties: Dependencies are injected into the bean.</li> <li>Set Bean Name: If the bean implements <code>BeanNameAware</code>, <code>setBeanName()</code> is called.</li> <li>Set Bean Factory: If the bean implements <code>BeanFactoryAware</code>, <code>setBeanFactory()</code> is called.</li> <li>Pre-Initialization: <code>BeanPostProcessors</code> are applied before initialization.</li> <li>Initialization: The container calls <code>afterPropertiesSet()</code> (if <code>InitializingBean</code> is implemented) or a custom init method.</li> <li>Post-Initialization: <code>BeanPostProcessors</code> are applied after initialization.</li> <li>Ready for Use: The bean is now available for use.</li> <li>Destruction: The container calls <code>destroy()</code> (if <code>DisposableBean</code> is implemented) or a custom destroy method.</li> </ol>"},{"location":"spring-basics/#base-classes-for-examples","title":"Base Classes for Examples","text":"<p>The following base classes are used across all examples in this document. Refer to these classes for context when reviewing the examples.</p> Example Processor.javaMemory.javaComputer.java <pre><code>public class Processor {\n    private String brand;\n    private String model;\n\n    public Processor() {}\n\n    public Processor(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n    }\n\n    public String getBrand() {\n        return brand;\n    }\n\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    public String getModel() {\n        return model;\n    }\n\n    public void setModel(String model) {\n        this.model = model;\n    }\n\n    public String getDetails() {\n        return brand + \" \" + model;\n    }\n}\n</code></pre> <pre><code>public class Memory {\n    private String type;\n    private int size;\n\n    public Memory() {}\n\n    public Memory(String type, int size) {\n        this.type = type;\n        this.size = size;\n    }\n\n    public String getType() {\n        return type;\n    }\n\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    public int getSize() {\n        return size;\n    }\n\n    public void setSize(int size) {\n        this.size = size;\n    }\n\n    public String getDetails() {\n        return type + \" \" + size + \"GB\";\n    }\n}\n</code></pre> <pre><code>public class Computer {\n    private Processor processor;\n    private Memory memory;\n\n    public Computer() {}\n\n    public Computer(Processor processor, Memory memory) {\n        this.processor = processor;\n        this.memory = memory;\n    }\n\n    public Processor getProcessor() {\n        return processor;\n    }\n\n    public void setProcessor(Processor processor) {\n        this.processor = processor;\n    }\n\n    public Memory getMemory() {\n        return memory;\n    }\n\n    public void setMemory(Memory memory) {\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Computer Specs:\");\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#spring-configuration-methods","title":"Spring Configuration Methods","text":"<p>Spring provides multiple ways to configure applications:</p> Spring Configuration XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <ul> <li>XML configuration is the traditional way of configuring Spring applications.</li> <li>It uses an XML file to define beans and their dependencies.</li> <li>XML files are usually placed in the <code>src/main/resources</code> directory.</li> <li>The XML file is loaded into the Spring context using <code>ClassPathXmlApplicationContext</code>.</li> </ul> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"\n   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n   xsi:schemaLocation=\"http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt;\n    &lt;!-- Define beans here --&gt;\n&lt;/beans&gt;\n</code></pre> <ul> <li>Java-based configuration uses Java classes to define beans and their dependencies.</li> <li>It is more type-safe and allows for better refactoring.</li> <li>Java configuration classes are annotated with <code>@Configuration</code> and use <code>@Bean</code> to define beans.</li> </ul> <pre><code>@Configuration\npublic class AppConfig {\n    // Define beans here\n}\n</code></pre> <ul> <li>Annotation-based configuration uses annotations to define beans and their dependencies.</li> <li>It is more concise and easier to read compared to XML configuration.</li> <li>Common annotations include <code>@Component</code>, <code>@Autowired</code>, and <code>@Configuration</code>.</li> </ul> <pre><code>@Configuration\n@ComponentScan(basePackages = \"com.example\")\npublic class AppConfig {\n    // No need to define beans explicitly, Spring will scan for @Component annotations\n}\n</code></pre>"},{"location":"spring-basics/#load-the-spring-context","title":"Load the Spring Context","text":"<p>Spring context can be loaded in different ways:</p> Spring Context XML ConfigurationJava-based ConfigurationAnnotation-based ConfigurationGetting Bean <pre><code>ApplicationContext context = new ClassPathXmlApplicationContext(\"config_file_name.xml\");\n</code></pre> <pre><code>ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n</code></pre> <pre><code>ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n</code></pre> <pre><code>Computer computer = context.getBean(\"computer\", Computer.class);\ncomputer.displaySpecs(); // (1)!\n</code></pre> <ol> <li> Output<pre><code>Computer Specs:\nProcessor: Intel Core i7\nMemory: DDR4 16GB\n</code></pre> </li> </ol>"},{"location":"spring-basics/#scope-of-beans","title":"Scope of Beans","text":"<p>Spring supports different bean scopes:</p> <ol> <li>Singleton: Default scope. A single instance is created and shared across the application.</li> <li>Prototype: A new instance is created each time the bean is requested.</li> <li>Request: A new instance is created for each HTTP request (web applications).</li> <li>Session: A new instance is created for each HTTP session (web applications).</li> <li>Global Session: A new instance is created for each global HTTP session (web applications).</li> <li>Application: A single instance is created for the lifecycle of the application context.</li> <li>WebSocket: A new instance is created for each WebSocket session (web applications).</li> </ol> Spring Bean Scopes XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <pre><code>&lt;bean id=\"myBean\" class=\"com.example.MyBean\" scope=\"prototype\"/&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    @Scope(\"prototype\")\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n</code></pre> <pre><code>@Component\n@Scope(\"prototype\")\npublic class MyBean {\n}\n</code></pre>"},{"location":"spring-basics/#dependency-injection","title":"Dependency Injection","text":"<p>Spring supports multiple ways to inject dependencies into beans. The most common methods are:</p>"},{"location":"spring-basics/#setter-injection","title":"Setter Injection","text":"<p>Setter injection uses setter methods to inject dependencies into a bean. It is flexible and allows changing dependencies at runtime. Must have setter methods defined in the class.</p> Example XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <pre><code>&lt;bean id=\"processor\" class=\"com.example.Processor\"&gt;\n    &lt;property name=\"brand\" value=\"Intel\"/&gt;\n    &lt;property name=\"model\" value=\"Core i7\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"memory\" class=\"com.example.Memory\"&gt;\n    &lt;property name=\"type\" value=\"DDR4\"/&gt;\n    &lt;property name=\"size\" value=\"16\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"computer\" class=\"com.example.Computer\"&gt;\n    &lt;property name=\"processor\" ref=\"processor\"/&gt;\n    &lt;property name=\"memory\" ref=\"memory\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public Processor processor() {\n        Processor processor = new Processor();\n        processor.setBrand(\"Intel\");\n        processor.setModel(\"Core i7\");\n        return processor;\n    }\n\n    @Bean\n    public Memory memory() {\n        Memory memory = new Memory();\n        memory.setType(\"DDR4\");\n        memory.setSize(16);\n        return memory;\n    }\n\n    @Bean\n    public Computer computer() {\n        Computer computer = new Computer();\n        computer.setProcessor(processor());\n        computer.setMemory(memory());\n        return computer;\n    }\n}\n</code></pre> Processor.javaMemory.javaComputer.java <pre><code>@Component\npublic class Processor {\n    private String brand;\n    private String model;\n\n    @Value(\"Intel\")\n    public void setBrand(String brand) {\n        this.brand = brand;\n    }\n\n    @Value(\"Core i7\")\n    public void setModel(String model) {\n        this.model = model;\n    }\n\n    public String getDetails() {\n        return brand + \" \" + model;\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Memory {\n    private String type;\n    private int size;\n\n    @Value(\"DDR4\")\n    public void setType(String type) {\n        this.type = type;\n    }\n\n    @Value(\"16\")\n    public void setSize(int size) {\n        this.size = size;\n    }\n\n    public String getDetails() {\n        return type + \" \" + size + \"GB\";\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    private Processor processor;\n    private Memory memory;\n\n    @Autowired\n    public void setProcessor(Processor processor) {\n        this.processor = processor;\n    }\n\n    @Autowired\n    public void setMemory(Memory memory) {\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Computer Specs:\");\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#constructor-injection","title":"Constructor Injection","text":"<p>Constructor injection uses constructor parameters to inject dependencies into a bean. It is useful when dependencies are mandatory and cannot be changed at runtime.</p> Example XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <pre><code>&lt;bean id=\"processor\" class=\"com.example.Processor\"&gt;\n    &lt;constructor-arg value=\"Intel\"/&gt;\n    &lt;constructor-arg value=\"Core i7\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"memory\" class=\"com.example.Memory\"&gt;\n    &lt;constructor-arg value=\"DDR4\"/&gt;\n    &lt;constructor-arg value=\"16\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"computer\" class=\"com.example.Computer\"&gt;\n    &lt;constructor-arg ref=\"processor\"/&gt;\n    &lt;constructor-arg ref=\"memory\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public Processor processor() {\n        return new Processor(\"Intel\", \"Core i7\");\n    }\n\n    @Bean\n    public Memory memory() {\n        return new Memory(\"DDR4\", 16);\n    }\n\n    @Bean\n    public Computer computer() {\n        return new Computer(processor(), memory());\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    private final Processor processor;\n    private final Memory memory;\n\n    @Autowired\n    public Computer(Processor processor, Memory memory) {\n        this.processor = processor;\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#field-injection","title":"Field Injection","text":"<p>Field injection uses annotations to inject dependencies directly into the fields of a bean. It is less verbose but can make testing and refactoring more difficult. It is generally not recommended for production code.</p> Example <pre><code>@Component\npublic class Computer {\n    @Autowired\n    private Processor processor;\n\n    @Autowired\n    private Memory memory;\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#autowiring","title":"Autowiring","text":"<p>Autowiring automatically resolves and injects dependencies into a bean. It reduces the need for explicit configuration. There are several modes of autowiring:</p> <ol> <li>No Autowiring: Default mode. No autowiring is performed.</li> <li>By Type: The container looks for a bean of the same type and injects it.</li> <li>By Name: The container looks for a bean with the same name as the property and injects it.</li> <li>Constructor: The container looks for a constructor with matching types and injects the dependencies.</li> <li>By Type with Qualifier: The container looks for a bean of the same type and uses the <code>@Qualifier</code> annotation to resolve ambiguity.</li> <li>By Name with Qualifier: The container looks for a bean with the same name as the property and uses the <code>@Qualifier</code> annotation to resolve ambiguity.</li> <li>By Type with Primary: The container looks for a bean of the same type and uses the <code>@Primary</code> annotation to resolve ambiguity.</li> <li>By Name with Primary: The container looks for a bean with the same name as the property and uses the <code>@Primary</code> annotation to resolve ambiguity.</li> <li>By Type with Factory Method: The container looks for a factory method that returns a bean of the same type and injects it.</li> <li>By Name with Factory Method: The container looks for a factory method that returns a bean with the same name as the property and injects it.</li> <li>By Type with Factory Bean: The container looks for a factory bean that returns a bean of the same type and injects it.</li> </ol> Example XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <pre><code>&lt;bean id=\"processor\" class=\"com.example.Processor\"&gt;\n    &lt;property name=\"brand\" value=\"Intel\"/&gt;\n    &lt;property name=\"model\" value=\"Core i7\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"memory\" class=\"com.example.Memory\"&gt;\n    &lt;property name=\"type\" value=\"DDR4\"/&gt;\n    &lt;property name=\"size\" value=\"16\"/&gt;\n&lt;/bean&gt;\n&lt;bean id=\"computer\" class=\"com.example.Computer\" autowire=\"byName\"/&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public Processor processor() {\n        return new Processor(\"Intel\", \"Core i7\");\n    }\n\n    @Bean\n    public Memory memory() {\n        return new Memory(\"DDR4\", 16);\n    }\n\n    @Bean\n    public Computer computer() {\n        return new Computer(processor(), memory());\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    @Autowired\n    private Processor processor;\n\n    @Autowired\n    private Memory memory;\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#using-primary-to-resolve-bean-ambiguity","title":"Using <code>Primary</code> to Resolve Bean Ambiguity","text":"<p>When multiple beans of the same type are eligible for injection you can explicitly use the bean name, in java based config Use <code>Qualifier</code> or use the <code>@Primary</code> annotation or the <code>primary</code> attribute in XML can be used to mark one bean as the default choice.</p> Example Class DefinitionXML ConfigurationJava-based ConfigurationAnnotation-based Configuration Processor.javaComputer.java <pre><code>public class Processor {\n    private String brand;\n    private String model;\n\n    public Processor(String brand, String model) {\n        this.brand = brand;\n        this.model = model;\n    }\n\n    public String getDetails() {\n        return brand + \" \" + model;\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    @Autowired\n    private Processor processor;\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n    }\n}\n</code></pre> <pre><code>&lt;bean id=\"intelProcessor\" class=\"com.example.Processor\"&gt;\n    &lt;constructor-arg value=\"Intel\"/&gt;\n    &lt;constructor-arg value=\"Core i7\"/&gt;\n&lt;/bean&gt;\n\n&lt;bean id=\"amdProcessor\" class=\"com.example.Processor\" primary=\"true\"&gt;\n    &lt;constructor-arg value=\"AMD\"/&gt;\n    &lt;constructor-arg value=\"Ryzen 7\"/&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public Processor intelProcessor() {\n        return new Processor(\"Intel\", \"Core i7\");\n    }\n\n    @Bean\n    @Primary\n    public Processor amdProcessor() {\n        return new Processor(\"AMD\", \"Ryzen 7\");\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    @Autowired\n    @Qualifier(\"amdProcessor\") // specify the bean name to be injected\n    private Processor processor;\n\n    @Autowired\n    @Qualifier(\"memory\") // specify the bean name to be injected\n    private Memory memory;\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-basics/#inner-beans","title":"Inner Beans","text":"<p>Inner beans are beans defined within the <code>&lt;property&gt;</code> or <code>&lt;constructor-arg&gt;</code> tags of another bean. They are used when a bean is only relevant as a dependency of another bean and does not need to be reused elsewhere.</p> Example XML ConfigurationJava-based ConfigurationAnnotation-based Configuration <pre><code>&lt;bean id=\"computer\" class=\"com.example.Computer\"&gt;\n    &lt;constructor-arg&gt;\n        &lt;bean class=\"com.example.Processor\"&gt;\n            &lt;constructor-arg value=\"Intel\"/&gt;\n            &lt;constructor-arg value=\"Core i7\"/&gt;\n        &lt;/bean&gt;\n    &lt;/constructor-arg&gt;\n    &lt;constructor-arg&gt;\n        &lt;bean class=\"com.example.Memory\"&gt;\n            &lt;constructor-arg value=\"DDR4\"/&gt;\n            &lt;constructor-arg value=\"16\"/&gt;\n        &lt;/bean&gt;\n    &lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre> <pre><code>@Configuration\npublic class AppConfig {\n    @Bean\n    public Computer computer() {\n        return new Computer(\n            new Processor(\"Intel\", \"Core i7\"),\n            new Memory(\"DDR4\", 16)\n        );\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    private Processor processor;\n    private Memory memory;\n\n    @Autowired\n    public void setProcessor(Processor processor) {\n        this.processor = processor;\n    }\n\n    @Autowired\n    public void setMemory(Memory memory) {\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Computer Specs:\");\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"spring-jdbc/","title":"Spring JDBC","text":"<p>Spring JDBC is a module of the Spring Framework that simplifies database access using JDBC (Java Database Connectivity). It abstracts away much of the boilerplate code (connection management, exception handling, etc.) and provides a consistent API for interacting with any JDBC-compliant database.</p>"},{"location":"spring-jdbc/#key-components","title":"Key Components","text":"Spring JDBC Core Components <ul> <li>JdbcTemplate: Core class for executing SQL queries, updates, and batch operations.</li> <li>RowMapper: Maps rows of a <code>ResultSet</code> to Java objects.</li> <li>ResultSetExtractor: Extracts data from a <code>ResultSet</code> (for custom mapping).</li> <li>NamedParameterJdbcTemplate: Like <code>JdbcTemplate</code>, but supports named parameters in SQL.</li> <li>SimpleJdbcCall: Simplifies calling stored procedures/functions.</li> <li>SimpleJdbcInsert: Simplifies insert operations.</li> <li>DataSource: Factory for database connections (e.g., <code>DriverManagerDataSource</code>, HikariCP).</li> <li>Transaction Management: Integrates with Spring's transaction management.</li> <li>Exception Translation: Converts JDBC exceptions to Spring's <code>DataAccessException</code> hierarchy.</li> <li>Batch Processing: Efficiently executes multiple statements in a batch.</li> <li>Connection Management: Handles opening/closing connections and supports pooling.</li> <li>Integration: Works seamlessly with other Spring modules (MVC, Security, etc.).</li> <li>Database Agnostic: Consistent API for any JDBC-compliant database.</li> </ul>"},{"location":"spring-jdbc/#basic-usage","title":"Basic Usage","text":"How to Use Spring JDBC Dependenciesapplication.propertiesJava-based ConfigurationRepository.java <pre><code>// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-jdbc\nimplementation 'org.springframework.boot:spring-boot-starter-jdbc:3.4.5'\n// https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-jpa\nruntimeOnly 'com.h2database:h2:2.3.232'\n// https://mvnrepository.com/artifact/org.springframework/spring-jdbc\nimplementation 'org.postgresql:postgresql:42.7.5'\n// https://mvnrepository.com/artifact/com.mysql/mysql-connector-j\nimplementation 'com.mysql:mysql-connector-j:9.3.0'\n</code></pre> <pre><code>spring.datasource.url=jdbc:postgresql://localhost:5432/testdb\nspring.datasource.username=user\nspring.datasource.password=password\nspring.datasource.driver-class-name=org.postgresql.Driver\n\n# H2 database configuration (for development/testing)\nspring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE\nspring.h2.console.enabled=true\n\n# The following are defaults in Spring Boot and can be omitted unless you want to override them:\n# spring.h2.console.path=/h2-console\n# spring.datasource.initialization-mode=always\n# spring.datasource.schema=classpath:schema.sql\n# spring.datasource.data=classpath:data.sql\n</code></pre> <pre><code>import org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.datasource.DriverManagerDataSource;\nimport javax.sql.DataSource;\n\n@Configuration\npublic class DataSourceConfig {\n    @Bean\n    public DataSource dataSource() {\n        DriverManagerDataSource ds = new DriverManagerDataSource();\n        ds.setDriverClassName(\"org.postgresql.Driver\");\n        ds.setUrl(\"jdbc:postgresql://localhost:5432/testdb\");\n        ds.setUsername(\"user\");\n        ds.setPassword(\"password\");\n        return ds;\n    }\n}\n</code></pre> <pre><code>public class Repository {\n    private JdbcTemplate jdbcTemplate;\n\n    @Autowired\n    public void setJdbcTemplate(JdbcTemplate jdbcTemplate) {\n        this.jdbcTemplate = jdbcTemplate;\n    }\n\n    public void createTable() {\n        String sql = \"CREATE TABLE users (id INT PRIMARY KEY, name VARCHAR(50))\";\n        jdbcTemplate.execute(sql);\n    }\n\n    public void insertUser(int id, String name) {\n        String sql = \"INSERT INTO users (id, name) VALUES (?, ?)\";\n        jdbcTemplate.update(sql, id, name);\n    }\n\n    public User getUser(int id) {\n        String sql = \"SELECT * FROM users WHERE id = ?\";\n        return jdbcTemplate.queryForObject(\n            sql,\n            new Object[]{id},\n            (rs, rowNum) -&gt; new User(rs.getInt(\"id\"), rs.getString(\"name\"))\n        );\n    }\n}\n</code></pre>"},{"location":"spring-jdbc/#best-practices-tips","title":"Best Practices &amp; Tips","text":"Recommendations <ul> <li>Prefer <code>JdbcTemplate</code> for most use cases; it handles resource management and exception translation.</li> <li>Always use parameterized queries (<code>?</code> or named parameters) to prevent SQL injection.</li> <li>Use <code>RowMapper</code> for mapping result sets to domain objects; avoid manual mapping in business logic.</li> <li>For batch operations, use <code>batchUpdate</code> for better performance.</li> <li>Use connection pooling (<code>HikariCP</code>, <code>BasicDataSource</code>, etc.) for production environments.</li> <li>Handle transactions declaratively with <code>@Transactional</code> where possible.</li> <li>Catch and handle only <code>DataAccessException</code> (not raw JDBC exceptions).</li> <li>Keep SQL in a separate file or as constants for maintainability in larger projects.</li> <li>Use <code>NamedParameterJdbcTemplate</code> for complex queries with many parameters for better readability.</li> <li>Test your SQL queries independently to ensure correctness and performance.</li> </ul>"},{"location":"spring-jdbc/#additional-notes","title":"Additional Notes","text":"Other Considerations <ul> <li>Testing: Use in-memory databases (like H2) for integration testing with Spring JDBC.</li> <li>Error Handling: Spring JDBC translates SQLExceptions into unchecked exceptions, so you don't need to catch checked exceptions.</li> <li>Performance: For large result sets, consider setting fetch size and using streaming.</li> <li>Migration: If you need more advanced ORM features later, you can migrate to Spring Data JPA or Hibernate with minimal changes to your configuration.</li> <li>Documentation: Refer to the Spring JDBC documentation for more advanced usage and best practices.</li> </ul>"},{"location":"springboot/","title":"Spring Boot Basics","text":""},{"location":"springboot/#introduction-to-spring-boot","title":"Introduction to Spring Boot","text":"<p>Spring Boot simplifies the development of Spring-based applications by providing pre-configured setups and reducing boilerplate code. It is built on top of the Spring Framework.</p>"},{"location":"springboot/#key-features-of-spring-boot","title":"Key Features of Spring Boot","text":"<ol> <li>Auto-Configuration: Automatically configures Spring beans based on the classpath and application properties.</li> <li>Standalone Applications: Allows running applications without requiring an external application server.</li> <li>Embedded Servers: Comes with embedded servers like Tomcat, Jetty, or Undertow.</li> <li>Production-Ready Features: Includes metrics, health checks, and externalized configuration.</li> <li>Spring Boot Starter Dependencies: Simplifies dependency management by providing starter POMs.</li> <li>Spring Boot CLI: Allows running Groovy scripts for rapid prototyping.</li> </ol>"},{"location":"springboot/#spring-boot-application","title":"Spring Boot Application","text":"Example Application.java<pre><code>package com.example;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        ApplicationContext context = SpringApplication.run(Application.class, args);\n        Computer computer = context.getBean(\"computer\", Computer.class);\n        computer.displaySpecs();\n    }\n}\n</code></pre>"},{"location":"springboot/#dependency-injection-in-spring-boot","title":"Dependency Injection in Spring Boot","text":"<p>Spring Boot supports dependency injection using annotations like <code>@Autowired</code>, <code>@Qualifier</code>, and <code>@Primary</code>.</p> Example Field InjectionConstructor InjectionSetter Injection <pre><code>@Component\npublic class Computer {\n    @Autowired\n    private Processor processor;\n\n    @Autowired\n    private Memory memory;\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    private final Processor processor;\n    private final Memory memory;\n\n    @Autowired\n    public Computer(Processor processor, Memory memory) {\n        this.processor = processor;\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre> <pre><code>@Component\npublic class Computer {\n    private Processor processor;\n    private Memory memory;\n\n    @Autowired\n    public void setProcessor(Processor processor) {\n        this.processor = processor;\n    }\n\n    @Autowired\n    public void setMemory(Memory memory) {\n        this.memory = memory;\n    }\n\n    public void displaySpecs() {\n        System.out.println(\"Processor: \" + processor.getDetails());\n        System.out.println(\"Memory: \" + memory.getDetails());\n    }\n}\n</code></pre>"},{"location":"springboot/#configuration-properties","title":"Configuration Properties","text":"<p>Spring Boot allows binding external configuration to Java objects using <code>@ConfigurationProperties</code>.</p> Example Configuration Classapplication.propertiesUsage <pre><code>@Component\n@ConfigurationProperties(prefix = \"app\")\npublic class AppConfig {\n    private String name;\n    private String version;\n\n    // Getters and setters\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public String getVersion() {\n        return version;\n    }\n\n    public void setVersion(String version) {\n        this.version = version;\n    }\n}\n</code></pre> <pre><code>app.name=SpringBootApp\napp.version=1.0.0\n</code></pre> <pre><code>@RestController\npublic class AppController {\n    @Autowired\n    private AppConfig appConfig;\n\n    @GetMapping(\"/info\")\n    public String getAppInfo() {\n        return \"App: \" + appConfig.getName() + \", Version: \" + appConfig.getVersion();\n    }\n}\n</code></pre>"},{"location":"springboot/#profiles-in-spring-boot","title":"Profiles in Spring Boot","text":"<p>Spring Boot supports profiles to define environment-specific configurations.</p> Example application-dev.propertiesapplication-prod.propertiesActivating Profiles <pre><code>server.port=8081\n</code></pre> <pre><code>server.port=8082\n</code></pre> <pre><code>java -Dspring.profiles.active=dev -jar app.jar\n</code></pre>"},{"location":"springboot/#validation","title":"Validation","text":"<p>Spring Boot supports validation using <code>@Valid</code> and <code>@Validated</code>.</p> Example DTO ClassController <pre><code>public class UserDTO {\n    @NotNull\n    @Size(min = 3, max = 50)\n    private String name;\n\n    @Email\n    private String email;\n\n    // Getters and setters\n}\n</code></pre> <pre><code>@RestController\npublic class UserController {\n    @PostMapping(\"/users\")\n    public ResponseEntity&lt;String&gt; createUser(@Valid @RequestBody UserDTO user) {\n        return ResponseEntity.ok(\"User created: \" + user.getName());\n    }\n}\n</code></pre>"},{"location":"springboot/#event-handling","title":"Event Handling","text":"<p>Spring Boot supports event handling using <code>ApplicationEvent</code> and <code>@EventListener</code>.</p> Example Custom EventEvent PublisherEvent Listener <pre><code>public class CustomEvent extends ApplicationEvent {\n    private String message;\n\n    public CustomEvent(Object source, String message) {\n        super(source);\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n</code></pre> <pre><code>@Component\npublic class EventPublisher {\n    @Autowired\n    private ApplicationEventPublisher publisher;\n\n    public void publishEvent(String message) {\n        publisher.publishEvent(new CustomEvent(this, message));\n    }\n}\n</code></pre> <pre><code>@Component\npublic class EventListener {\n    @EventListener\n    public void handleCustomEvent(CustomEvent event) {\n        System.out.println(\"Received event: \" + event.getMessage());\n    }\n}\n</code></pre>"},{"location":"springboot/#logging","title":"Logging","text":"<p>Spring Boot uses SLF4J with Logback as the default logging framework.</p> Example application.propertiesUsage <pre><code>logging.level.org.springframework=DEBUG\nlogging.file.name=app.log\n</code></pre> <pre><code>@RestController\npublic class LoggingController {\n    private static final Logger logger = LoggerFactory.getLogger(LoggingController.class);\n\n    @GetMapping(\"/log\")\n    public String logMessage() {\n        logger.info(\"This is an info message\");\n        return \"Check the logs!\";\n    }\n}\n</code></pre>"}]}